
type base_type_t = Utypes.base_type_t ;
type env_t = Utypes.Env.t bool unit unit ;
module Bound = Utypes.Bound ;
type size_constraint_t = Utypes.size_constraint_t ;
type range_constraint_t = Utypes.range_constraint_t ;
type module_path_t = Utypes.module_path_t ;
type ref_t = Utypes.ref_t ;
type string_list = list string ;
type yojson = Yojson.Basic.t ;
type yojson_list = list Yojson.Basic.t ;
type id_t = Utypes.ID.t ;

module REC = struct
type loc = Ploc.t ;

ATTRIBUTE_GRAMMAR
  DEBUG True ;
  MODULE AG ;
  ATTRIBUTION_MODEL Attributed {
    attributed_module_name = AT
  } ;
  PRIMITIVES loc, base_type_t, size_constraint_t, range_constraint_t, ref_t, string_list, size_constraint_t,
  range_constraint_t, yojson, yojson_list, id_t, module_path_t ;
  AXIOM utype_t ;

ATTRIBUTES
  env : env_t ;
  it_utype_t : Utypes.utype_t ;
  it_utype_t_list : list Utypes.utype_t ;
  it_atomic_utype_t : Utypes.atomic_utype_t ;
  it_atomic_utype_t_list : list Utypes.atomic_utype_t ;
  it_re_utype_t_list : list (string * Utypes.utype_t) ;
  it_utype_t_option : option Utypes.utype_t ;
  it_struct_item_t : Utypes.struct_item_t ;
  it_sig_item_t : Utypes.sig_item_t ;
  it_utype_t_binding_list : list (id_t * bool * Utypes.utype_t) ;
  it_structure : list Utypes.struct_item_t ;
  it_signature : list Utypes.sig_item_t ;
  it_module_expr_t : Utypes.module_expr_t ;
  it_module_type_t : Utypes.module_type_t ;
END ;

RULE UtTrue : utype_t := loc
COMPUTE
  $[0].it_utype_t := Utypes.UtTrue $[1] ;
END ;

RULE UtFalse : utype_t := loc
COMPUTE
  $[0].it_utype_t := Utypes.UtFalse $[1] ;
END ;

RULE Simple : utype_t := loc and base_type_t
COMPUTE
  $[0].it_utype_t := Utypes.Simple $[1] $[2] ;
END ;

RULE And : utype_t := loc and utype_t and utype_t
COMPUTE
  $[0].it_utype_t := Utypes.And $[1] $[2].it_utype_t $[3].it_utype_t ;
END ;

RULE Or : utype_t := loc and utype_t and utype_t
COMPUTE
  $[0].it_utype_t := Utypes.Or $[1] $[2].it_utype_t $[3].it_utype_t ;
END ;

RULE Xor : utype_t := loc and utype_t and utype_t
COMPUTE
  $[0].it_utype_t := Utypes.Xor $[1] $[2].it_utype_t $[3].it_utype_t ;
END ;

RULE Impl : utype_t := loc and utype_t and utype_t
COMPUTE
  $[0].it_utype_t := Utypes.Impl $[1] $[2].it_utype_t $[3].it_utype_t ;
END ;

RULE Not : utype_t := loc and utype_t
COMPUTE
  $[0].it_utype_t := Utypes.Not $[1] $[2].it_utype_t ;
END ;

RULE AtomicSingleton : atomic_utype_t_list := atomic_utype_t
COMPUTE
  $[0].it_atomic_utype_t_list := [ $[1].it_atomic_utype_t ] ;
END ;

RULE AtomicCons : atomic_utype_t_list := atomic_utype_t and atomic_utype_t_list
COMPUTE
  $[0].it_atomic_utype_t_list := [ $[1].it_atomic_utype_t :: $[2].it_atomic_utype_t_list ] ;
END ;

RULE Atomic : utype_t := loc and atomic_utype_t_list
COMPUTE
  $[0].it_utype_t := Utypes.Atomic $[1] $[2].it_atomic_utype_t_list ;
END ;

RULE Ref : utype_t := loc and ref_t
COMPUTE
  $[0].it_utype_t := Utypes.Ref $[1] $[2] ;
END ;

RULE UtOption_None : utype_t_option
COMPUTE
  $[0].it_utype_t_option := None ;
END ;

RULE UtOption_Some : utype_t_option := utype_t
COMPUTE
  $[0].it_utype_t_option := Some $[1].it_utype_t ;
END ;

RULE REUT_Singleton : re_utype_t_list := string and utype_t
COMPUTE
  $[0].it_re_utype_t_list := [($[1], $[2].it_utype_t)] ;
END ;

RULE REUT_Cons : re_utype_t_list := string and utype_t and re_utype_t_list
COMPUTE
  $[0].it_re_utype_t_list := [ ($[1], $[2].it_utype_t):: $[3].it_re_utype_t_list ] ;
END ;

RULE Seal : utype_t := loc and utype_t and re_utype_t_list and utype_t_option
COMPUTE
  $[0].it_utype_t := Utypes.Seal $[1] $[2].it_utype_t $[3].it_re_utype_t_list $[4].it_utype_t_option ;
END ;

RULE Field : atomic_utype_t := loc and string and utype_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.Field $[1] $[2] $[3].it_utype_t ;
END ;

RULE FieldRE : atomic_utype_t := loc and string and utype_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.FieldRE $[1] $[2] $[3].it_utype_t ;
END ;

RULE FieldRequired : atomic_utype_t := loc and string_list
COMPUTE
  $[0].it_atomic_utype_t := Utypes.FieldRequired $[1] $[2] ;
END ;

RULE ArrayOf : atomic_utype_t := loc and utype_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.ArrayOf $[1] $[2].it_utype_t ;
END ;

RULE UtSingleton : utype_t_list := utype_t
COMPUTE
  $[0].it_utype_t_list := [ $[1].it_utype_t ] ;
END ;

RULE UtCons : utype_t_list := utype_t and utype_t_list
COMPUTE
  $[0].it_utype_t_list := [ $[1].it_utype_t :: $[2].it_utype_t_list ] ;
END ;

RULE ArrayTuple : atomic_utype_t := loc and utype_t_list
COMPUTE
  $[0].it_atomic_utype_t := Utypes.ArrayTuple $[1] $[2].it_utype_t_list ;
END ;

RULE ArrayUnique : atomic_utype_t := loc
COMPUTE
  $[0].it_atomic_utype_t := Utypes.ArrayUnique $[1] ;
END ;

RULE ArrayIndex : atomic_utype_t := loc and int and utype_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.ArrayIndex $[1] $[2] $[3].it_utype_t ;
END ;

RULE Size : atomic_utype_t := loc and size_constraint_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.Size $[1] $[2] ;
END ;

RULE StringRE : atomic_utype_t := loc and string
COMPUTE
  $[0].it_atomic_utype_t := Utypes.StringRE $[1] $[2] ;
END ;

RULE NumberBound : atomic_utype_t := loc and range_constraint_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.NumberBound $[1] $[2] ;
END ;

RULE Sealed : atomic_utype_t := loc
COMPUTE
  $[0].it_atomic_utype_t := Utypes.Sealed $[1] ;
END ;

RULE OrElse : atomic_utype_t := loc and utype_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.OrElse $[1] $[2].it_utype_t ;
END ;

RULE MultipleOf : atomic_utype_t := loc and float
COMPUTE
  $[0].it_atomic_utype_t := Utypes.MultipleOf $[1] $[2] ;
END ;

RULE Enum : atomic_utype_t := loc and yojson_list
COMPUTE
  $[0].it_atomic_utype_t := Utypes.Enum $[1] $[2] ;
END ;

RULE Default : atomic_utype_t := loc and yojson
COMPUTE
  $[0].it_atomic_utype_t := Utypes.Default $[1] $[2] ;
END ;

RULE Format : atomic_utype_t := loc and string
COMPUTE
  $[0].it_atomic_utype_t := Utypes.Format $[1] $[2] ;
END ;

RULE PropertyNames : atomic_utype_t := loc and utype_t
COMPUTE
  $[0].it_atomic_utype_t := Utypes.PropertyNames $[1] $[2].it_utype_t ;
END ;

RULE ContentMediaType : atomic_utype_t := loc and string
COMPUTE
  $[0].it_atomic_utype_t := Utypes.ContentMediaType $[1] $[2] ;
END ;

RULE ContentEncoding : atomic_utype_t := loc and string
COMPUTE
  $[0].it_atomic_utype_t := Utypes.ContentEncoding $[1] $[2] ;
END ;

RULE UTTypeBindSingleton : utype_t_binding_list := id_t and bool and utype_t
COMPUTE
  $[0].it_utype_t_binding_list := [($[1], $[2], $[3].it_utype_t)] ;
END ;

RULE UTTypeBindCons : utype_t_binding_list := id_t and bool and utype_t and utype_t_binding_list
COMPUTE
  $[0].it_utype_t_binding_list := [ ($[1], $[2], $[3].it_utype_t) :: $[4].it_utype_t_binding_list ] ;
END ;

RULE StTypes : struct_item_t := loc and bool and utype_t_binding_list
COMPUTE
  $[0].it_struct_item_t := Utypes.StTypes $[1] $[2] $[3].it_utype_t_binding_list ;
END ;

RULE StModuleBinding : struct_item_t := loc and id_t and module_expr_t
COMPUTE
  $[0].it_struct_item_t := Utypes.StModuleBinding $[1] $[2] $[3].it_module_expr_t ;
END ;

RULE StImport : struct_item_t := loc and string and id_t
COMPUTE
  $[0].it_struct_item_t := Utypes.StImport $[1] $[2] $[3] ;
END ;

RULE StLocal : struct_item_t := loc and structure and structure
COMPUTE
  $[0].it_struct_item_t := Utypes.StLocal $[1] $[2].it_structure $[3].it_structure ;
END ;

RULE StOpen : struct_item_t := loc and module_path_t
COMPUTE
  $[0].it_struct_item_t := Utypes.StOpen $[1] $[2] None ;
END ;

RULE StInclude : struct_item_t := loc and module_path_t
COMPUTE
  $[0].it_struct_item_t := Utypes.StInclude $[1] $[2] None ;
END ;

RULE StModuleType : struct_item_t := loc and id_t and module_type_t
COMPUTE
  $[0].it_struct_item_t := Utypes.StModuleType $[1] $[2] $[3].it_module_type_t ;
END ;

RULE StructureNil : structure
COMPUTE
  $[0].it_structure := [] ;
END ;

RULE StructureCons : structure := struct_item_t and structure
COMPUTE
  $[0].it_structure := [ $[1].it_struct_item_t :: $[2].it_structure ] ;
END ;

RULE SignatureNil : signature
COMPUTE
  $[0].it_signature := [] ;
END ;

RULE SignatureCons : signature := sig_item_t and signature
COMPUTE
  $[0].it_signature := [ $[1].it_sig_item_t :: $[2].it_signature ] ;
END ;

RULE MeStruct : module_expr_t := loc and structure
COMPUTE
  $[0].it_module_expr_t := Utypes.MeStruct $[1] $[2].it_structure ;
END ;

RULE MeFunctorApp : module_expr_t := loc and module_expr_t and module_expr_t
COMPUTE
  $[0].it_module_expr_t := Utypes.MeFunctorApp $[1] $[2].it_module_expr_t $[3].it_module_expr_t ;
END ;

RULE MePath : module_expr_t := loc and module_path_t
COMPUTE
  $[0].it_module_expr_t := Utypes.MePath $[1] $[2] ;
END ;

RULE MeFunctor : module_expr_t := loc and id_t and module_type_t and module_expr_t
COMPUTE
  $[0].it_module_expr_t := Utypes.MeFunctor $[1] ($[2], $[3].it_module_type_t) $[4].it_module_expr_t ;
END ;

RULE MeCast : module_expr_t := loc and module_expr_t and module_type_t
COMPUTE
  $[0].it_module_expr_t := Utypes.MeCast $[1] $[2].it_module_expr_t $[3].it_module_type_t ;
END ;

RULE MtSig : module_type_t := loc and signature
COMPUTE
  $[0].it_module_type_t := Utypes.MtSig $[1] $[2].it_signature ;
END ;

RULE MtFunctorType : module_type_t := loc and id_t and module_type_t and module_type_t
COMPUTE
  $[0].it_module_type_t := Utypes.MtFunctorType $[1] ($[2], $[3].it_module_type_t) $[4].it_module_type_t ;
END ;

RULE MtPath : module_type_t := loc and ref_t
COMPUTE
  $[0].it_module_type_t := Utypes.MtPath $[1] $[2] ;
END ;

RULE SiType : sig_item_t := loc and id_t and bool
COMPUTE
  $[0].it_sig_item_t := Utypes.SiType $[1] $[2] $[3] ;
END ;

RULE SiModuleBinding : sig_item_t := loc and id_t and module_type_t
COMPUTE
  $[0].it_sig_item_t := Utypes.SiModuleBinding $[1] $[2] $[3].it_module_type_t ;
END ;

RULE SiModuleType : sig_item_t := loc and id_t and module_type_t
COMPUTE
  $[0].it_sig_item_t := Utypes.SiModuleType $[1] $[2] $[3].it_module_type_t ;
END ;

RULE SiInclude : sig_item_t := loc and module_path_t
COMPUTE
  $[0].it_sig_item_t := Utypes.SiInclude $[1] $[2] ;
END ;

END ;

end ;

(*
;;; Local Variables: ***
;;; mode:tuareg ***
;;; End: ***

*)
